<?php

namespace Net\TomasKadlec\LunchGuy\BaseBundle\Service\Parser;

use RuntimeException;
use Symfony\Component\DomCrawler\Crawler;

class Zomato extends AbstractParser {

    protected static $selector = '#menu-preview .tmi-groups .tmi-group';

    public function isSupported($format) {
        return ($format == 'zomato');
    }

    public function supports() {
        return ['zomato'];
    }

    public function parse($format, $data, $charset = 'UTF-8') {
        if (!$this->isSupported($format))
            return new RuntimeException("Format {$format} is not supported.");

        $data = $this
                ->getCrawler($data, $charset)
                ->filter(static::$selector)
                ->each(function (Crawler $node) {
                    $todayText = $node->filter('.tmi-group-name')
                        ->each(function (Crawler $node) {
                            return $node->text();
                        });

                    if(!preg_match("/\(dnes\)/", $todayText[0]))
                        return [];


                    return $node->filter('.tmi-daily')->each(function($node) {
                        return $node->text();
                    });
        });

        if(!$data || count($data) == 0) {
            return [];
        }

        $data = array_values($data)[0];

        return $this->process($data);
    }

    /**
     * Transforms data from the crawler to an internal array
     *
     * @param $data
     * @return array
     */
    protected function process($data) {
        $key = null;
        $result = [];

        foreach ($data as $row) {
            if (empty($row) || preg_match("/^\s*$/u", $row))
                continue;

            // alergens
            if (preg_match("/^\s*(\d+,?)+\s*\$/u", $row))
                continue;

            // some fake character
            if (preg_match("/^\s*¨+\s*\$/u", $row))
                continue;

            // remove meal numbers
            $row = preg_replace("/^\s*P\d+(.*)/ui", '$1', $row);
            $row = preg_replace("/^\s*M\d+(.*)/ui", '$1', $row);
            // remove grams
            $row = preg_replace("/^\s*\d+g/ui", '', $row);

            if (preg_match('/POLÉVKY/ui', $row)) {
                $key = static::KEY_SOUPS;
                continue;
            } else if (preg_match('/HLAVNÍ JÍDLA/ui', $row)) {
                $key = static::KEY_MAIN;
                continue;
            } else if (preg_match('/Salátky/ui', $row)) {
                $key = static::KEY_SALADS;
                continue;
            } else if (preg_match('/MOUČNÍK/ui', $row)) {
                $key = static::KEY_DESERTS;
                continue;
            }


            if ($key !== null) {
                $exploded = explode(" ", trim($row));
                $result[$key][] = [
                    trim(preg_replace("/\d+(,-|\s*Kč).*/ui", '', trim($row))),
                    (count($exploded) > 0 ? intval($exploded[count($exploded) - 1]) : '-')
                ];
            }
        }

        return $result;
    }

    /**
     * Return parser specific client for issuing HTTP requests.
     * 
     * @return mixed the HTTP client
     */
    public function getClient($format) {
        if (!$this->isSupported($format))
            return new \RuntimeException("Format {$format} is not supported.");

        $cmd = 'curl -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0"';
        return new CurlClient($cmd);
    }

    /**
     * Return parser specific client for issuing HTTP requests.
     *
     * @return mixed the HTTP client
     */
    public function getLibCurlClient($format) {
        if (!$this->isSupported($format))
            return new \RuntimeException("Format {$format} is not supported.");
        $headers = array();
        $headers[] = "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0";

        // Generated by curl-to-PHP: http://incarnate.github.io/curl-to-php/
        $ch = curl_init();

        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_0);
        curl_setopt($ch, CURLOPT_TIMEOUT, 60);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

        $headers = array();
        $headers[] = "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0";
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

        return new Client($ch);
    }

}

class Body {
    private $contents;
    
    function __construct($contents) {
        $this->contents = $contents;
    }
    
    function getContents() {
        return $this->contents;
    }
}

class Response {

    private $statusCode;
    private $body;

    function __construct($statusCode, $body) {
        $this->statusCode = $statusCode;
        $this->body = $body;
    }

    function getStatusCode() {
        return $this->statusCode;
    }

    function getBody() {
        return $this->body;
    }

}

class CurlClient {
    private $command;

    /**
     * CurlClient constructor.
     * @param $command
     */
    public function __construct($command)
    {
        $this->command = $command;
    }

    public function request($method, $uri, $data = []) {
        $command = $this->command . "-X '" . escapeshellcmd($method) . "' '" . escapeshellcmd($uri) . "'";
        exec($command, $output, $return_val);

        if($return_val !== 0) {
            return new Response(404, new Body(''));
        }

        return new Response(200, new Body(implode("\n", $output)));
    }
}


class Client {

    private $ch;

    function __construct($ch) {
        $this->ch = $ch;
    }

    public function request($method, $uri, $data = []) {
        curl_setopt($this->ch, CURLOPT_CUSTOMREQUEST, $method);
        curl_setopt($this->ch, CURLOPT_URL, $uri);

        try {
            $result = curl_exec($this->ch);
            $info = curl_getinfo($this->ch);

            if (curl_errno($this->ch)) {

                return new Response($info['http_code'], new Body($result));
            }
        } finally {
            curl_close($this->ch);
        }

        return new Response($info['http_code'], new Body($result));
    }

}
